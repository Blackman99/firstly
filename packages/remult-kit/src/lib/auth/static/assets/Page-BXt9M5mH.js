import{n as S,s as $t,r as nt,a as ot,i as te,g as ee,S as Q,b as V,c as Ct,d as y,e as ne,v as q,f as J,h as Z,j as Et,k as it,o as Kt,l as rt,m as oe,p as Ht,q as It,t as P,u as L,w as se,x as R,y as ie,z as E,A as Xt,B as Wt,C as Tt,D as ut,E as Lt,F as re,G as k,H as Dt,I as v,J as st,K as X,L as ae,M as j,N as K,O as b,P as qt,Q as O,R as I,T as Jt,U as et,V as A,W as F,X as N}from"./index-BxSQq6jY.js";function ce(e,t){const n={},o={},r={$$scope:1};let l=e.length;for(;l--;){const c=e[l],s=t[l];if(s){for(const a in c)a in s||(o[a]=1);for(const a in s)r[a]||(n[a]=s[a],r[a]=1);e[l]=s}else for(const a in c)r[a]=1}for(const c in o)c in n||(n[c]=void 0);return n}const H=[];function kt(e,t){return{subscribe:Y(e,t).subscribe}}function Y(e,t=S){let n;const o=new Set;function r(s){if(ot(e,s)&&(e=s,n)){const a=!H.length;for(const i of o)i[1](),H.push(i,e);if(a){for(let i=0;i<H.length;i+=2)H[i][0](H[i+1]);H.length=0}}}function l(s){r(s(e))}function c(s,a=S){const i=[s,a];return o.add(i),o.size===1&&(n=t(r,l)||S),s(e),()=>{o.delete(i),o.size===0&&n&&(n(),n=null)}}return{set:r,update:l,subscribe:c}}function M(e,t,n){const o=!Array.isArray(e),r=o?[e]:e;if(!r.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const l=t.length<2;return kt(n,(c,s)=>{let a=!1;const i=[];let f=0,u=S;const m=()=>{if(f)return;u();const _=t(o?i[0]:i,c,s);l?c(_):u=te(_)?_:S},g=r.map((_,w)=>$t(_,p=>{i[w]=p,f&=~(1<<w),a&&m()},()=>{f|=1<<w}));return a=!0,m(),function(){nt(g),u(),a=!1}})}const le=e=>{const{subscribe:t,update:n}=Y(e);return{subscribe:t,set:(o={})=>{n(r=>Object.assign(r,o))}}},W=le({mode:"window",basePath:null}),at=(e=ee(W).mode)=>{let t="popstate";e==="window"&&(t="popstate"),e==="hash"&&(t="hashchange"),window.dispatchEvent(new Event(t))},Rt={go:(e=0)=>{history.go(e),at()},push:(e,t=null)=>{history.pushState(t,"",e),at()},replace:(e,t=null)=>{history.replaceState(t,"",e),at()}},ue=(e,t)=>t===null?e:e.startsWith(t)?e.slice(t.length):e,fe=e=>{const t=e.match(/^(\/[^?#]*)?/),n=e.match(/\?([^#]*)?/),o=e.match(/#(.*)?/);return{path:(t==null?void 0:t[1])||"/",query:n!=null&&n[1]?`?${n==null?void 0:n[1]}`:"",hash:o!=null&&o[1]?`#${o==null?void 0:o[1]}`:""}},St=()=>{const{pathname:e,search:t,hash:n}=document.location;return{path:e,query:t,hash:n}},jt=()=>{let e=document.location.hash.substring(1);return e[0]!=="/"&&(e="/"+e),fe(e)},me=kt(St(),e=>{const t=()=>e(St());return window.addEventListener("popstate",t),()=>window.removeEventListener("popstate",t)}),de=kt(jt(),e=>{const t=()=>e(jt());return window.addEventListener("hashchange",t),()=>window.removeEventListener("hashchange",t)}),vt=M([W,me,de],([e,t,n],o)=>{e.mode==="window"&&o(t),e.mode==="hash"&&o(n)}),he=M(vt,e=>e.path);M(vt,e=>e.query);M(vt,e=>e.hash);const ct=M([W,he],([e,t])=>ue(t,e.basePath)),U=e=>e.split(/(?=\/)/),Gt=()=>{let e=0;return()=>e++},{Error:G}=ne;function ft(e){let t;const n=e[10].default,o=Ht(n,e,e[9],null),r={c:function(){o&&o.c()},m:function(c,s){o&&o.m(c,s),t=!0},p:function(c,s){o&&o.p&&(!t||s&512)&&Xt(o,n,c,c[9],t?Tt(n,c[9],s,null):Wt(c[9]),null)},i:function(c){t||(L(o,c),t=!0)},o:function(c){R(o,c),t=!1},d:function(c){o&&o.d(c)}};return y("SvelteRegisterBlock",{block:r,id:ft.name,type:"if",source:"(96:0) {#if isRouteActive($pathWithoutBase, $route, $contextChildRoutes)}",ctx:e}),r}function mt(e){let t=dt(e[1],e[0],e[2]),n,o,r=t&&ft(e);const l={c:function(){r&&r.c(),n=It()},l:function(s){throw new G("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){r&&r.m(s,a),P(s,n,a),o=!0},p:function(s,[a]){a&7&&(t=dt(s[1],s[0],s[2])),t?r?(r.p(s,a),a&7&&L(r,1)):(r=ft(s),r.c(),L(r,1),r.m(n.parentNode,n)):r&&(se(),R(r,1,1,()=>{r=null}),ie())},i:function(s){o||(L(r),o=!0)},o:function(s){R(r),o=!1},d:function(s){s&&E(n),r&&r.d(s)}};return y("SvelteRegisterBlock",{block:l,id:mt.name,type:"component",source:"",ctx:e}),l}const Bt=(e,t,n,o,r)=>{const l=(i,f,u)=>{const m=U(f).filter(g=>g!=="/").length;return(u??0)+(i?1:m)},c=(i,f)=>{const u={invalidPath:`<Route path="${i==null?void 0:i.path}" /> has invalid path. Path must start with '/'`,fallbackOutsideRoot:"<Route fallback /> cannot be outside root <Route />",pathOutsideRoot:`<Route path="${i==null?void 0:i.path}" /> cannot be outside root <Route />`,fallbackInsideFallback:"<Route fallback /> cannot be inside <Route fallback>",pathInsideFallback:`<Route path="${i==null?void 0:i.path}" /> cannot be inside <Route fallback>`};if(i.path[0]!=="/")throw new Error(u.invalidPath);if(i.root&&i.fallback)throw new Error(u.fallbackOutsideRoot);if(i.root&&i.path!=="/")throw new Error(u.pathOutsideRoot);if(f!=null&&f.fallback&&i.fallback)throw new Error(u.fallbackInsideFallback);if(f!=null&&f.fallback&&!i.fallback)throw new Error(u.pathInsideFallback)},s=l(n,o,r==null?void 0:r.depth),a={id:e,root:t,fallback:n,path:o,depth:s};return c(a,r),a},Ot=()=>{const{subscribe:e,update:t}=Y([]);return{subscribe:e,update:n=>t(o=>[...o.filter(r=>n.id!==r.id),n]),remove:n=>t(o=>o.filter(r=>n.id!==r.id))}},dt=(e,t,n)=>{const o=(i,f,u,m)=>{let g=U(i).filter(p=>p!=="/"),_=U(u).filter(p=>p!=="/"),w="";if(u==="/")return f||g.length===m;for(let p=m-_.length;p<m;p++)w=w+g[p];return u===w},r=(i,f,u)=>{var _,w,p,d;let m=U(i).filter(h=>h!=="/"),g=!1;for(let h=0;h<(u==null?void 0:u.length)&&!g;h++)(_=u[h])!=null&&_.fallback||(g=o(i,((w=u[h])==null?void 0:w.root)??!1,((p=u[h])==null?void 0:p.path)??"",((d=u[h])==null?void 0:d.depth)??0));return m.length>=f&&!g},{root:l,fallback:c,path:s,depth:a}=t;return c?r(e,a,n):o(e,l,s,a)},At=Gt(),$={},lt={};function pe(e,t,n){let o,r,l,c;q(ct,"pathWithoutBase"),J(e,ct,h=>n(1,l=h));let{$$slots:s={},$$scope:a}=t;Z("Route",s,["default"]);const i=At(),f=!Et($);let{fallback:u=!1}=t,{path:m="/"}=t;const g=Y();q(g,"route"),J(e,g,h=>n(0,o=h));const _=it($);q(_,"contextRoute"),J(e,_,h=>n(8,r=h));const w=Ot(),p=it(lt);q(p,"contextChildRoutes"),J(e,p,h=>n(2,c=h)),Kt(()=>p==null?void 0:p.remove(o)),rt($,g),rt(lt,w);const d=["fallback","path"];return Object.keys(t).forEach(h=>{!~d.indexOf(h)&&h.slice(0,2)!=="$$"&&h!=="slot"&&console.warn(`<Route> was created with unknown prop '${h}'`)}),e.$$set=h=>{"fallback"in h&&n(6,u=h.fallback),"path"in h&&n(7,m=h.path),"$$scope"in h&&n(9,a=h.$$scope)},e.$capture_state=()=>({writable:Y,createIdIssuer:Gt,getPathSegments:U,getRoute:Bt,createChildRoutes:Ot,isRouteActive:dt,getId:At,routeContextKey:$,childRoutesContextKey:lt,onDestroy:Kt,getContext:it,setContext:rt,hasContext:Et,pathWithoutBase:ct,id:i,root:f,fallback:u,path:m,route:g,contextRoute:_,childRoutes:w,contextChildRoutes:p,$route:o,$contextRoute:r,$pathWithoutBase:l,$contextChildRoutes:c}),e.$inject_state=h=>{"fallback"in h&&n(6,u=h.fallback),"path"in h&&n(7,m=h.path)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{e.$$.dirty&448&&oe(g,o=Bt(i,f,u,m,r),o),e.$$.dirty&1&&(p==null||p.update(o))},[o,l,c,g,_,p,u,m,r,a,s]}class z extends Q{constructor(t){super(t),V(this,t,pe,mt,Ct,{fallback:6,path:7}),y("SvelteRegisterComponent",{component:this,tagName:"Route",options:t,id:mt.name})}get fallback(){throw new G("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set fallback(t){throw new G("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get path(){throw new G("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set path(t){throw new G("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Ft=e=>{var s;const t=(s=e.target)==null?void 0:s.closest("a[href]"),n=t==null?void 0:t.href;if(t===null||n===null)return!0;const o=["","true"].includes(t.getAttribute("data-handle-ignore")??"false"),r=(t.getAttribute("target")??"_self")!=="_self",l=e.metaKey||e.ctrlKey||e.altKey||e.shiftKey,c=new URL(n).origin!==document.location.origin;if(o||r||l||c)return!0;n===document.location.href?Rt.replace(n):Rt.push(n),e.preventDefault()},yt=e=>(e.addEventListener("click",Ft),{destroy:()=>{e.removeEventListener("click",Ft)}}),ge="Users/ermin/Documents/work.nosync/remult-kit/node_modules/.pnpm/svelte-micro@2.5.6_svelte@4.2.12/node_modules/svelte-micro/dist/lib/components/Link.svelte";function ht(e){let t,n,o,r;const l=e[5].default,c=Ht(l,e,e[4],null);let s=[{href:e[0]},e[1]],a={};for(let f=0;f<s.length;f+=1)a=ut(a,s[f]);const i={c:function(){t=k("a"),c&&c.c(),Dt(t,a),v(t,ge,15,0,417)},l:function(u){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(u,m){P(u,t,m),c&&c.m(t,null),n=!0,o||(r=[st(yt.call(null,t)),X(t,"click",e[6],!1,!1,!1,!1)],o=!0)},p:function(u,[m]){c&&c.p&&(!n||m&16)&&Xt(c,l,u,u[4],n?Tt(l,u[4],m,null):Wt(u[4]),null),Dt(t,a=ce(s,[(!n||m&1)&&{href:u[0]},m&2&&u[1]]))},i:function(u){n||(L(c,u),n=!0)},o:function(u){R(c,u),n=!1},d:function(u){u&&E(t),c&&c.d(u),o=!1,nt(r)}};return y("SvelteRegisterBlock",{block:i,id:ht.name,type:"component",source:"",ctx:e}),i}const Nt=(e,t,n)=>(e==="hash"?"#":"")+(t??"")+n;function we(e,t,n){let o;const r=["href"];let l=Lt(t,r),c;q(W,"options"),J(e,W,u=>n(3,c=u));let{$$slots:s={},$$scope:a}=t;Z("Link",s,["default"]);let{href:i}=t;e.$$.on_mount.push(function(){i===void 0&&!("href"in t||e.$$.bound[e.$$.props.href])&&console.warn("<Link> was created without expected prop 'href'")});function f(u){ae.call(this,e,u)}return e.$$set=u=>{t=ut(ut({},t),re(u)),n(1,l=Lt(t,r)),"href"in u&&n(2,i=u.href),"$$scope"in u&&n(4,a=u.$$scope)},e.$capture_state=()=>({getFormatedHref:Nt,options:W,linkHandle:yt,href:i,formatedHref:o,$options:c}),e.$inject_state=u=>{"href"in t&&n(2,i=u.href),"formatedHref"in t&&n(0,o=u.formatedHref)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{e.$$.dirty&12&&n(0,o=Nt(c.mode,c.basePath,i))},[o,l,i,c,a,s,f]}class Pt extends Q{constructor(t){super(t),V(this,t,we,ht,Ct,{href:2}),y("SvelteRegisterComponent",{component:this,tagName:"Link",options:t,id:ht.name})}get href(){throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set href(t){throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function x(e){e.focus()}const tt="src/lib/modules/auth/components/ForgottenPassword.svelte";function pt(e){let t,n,o,r,l,c,s;const a={c:function(){t=k("div"),n=k("form"),o=k("input"),r=j(),l=k("button"),l.textContent="Send password reset instructions",K(o,"type","text"),K(o,"placeholder","Your email address"),v(o,tt,21,8,437),v(l,tt,22,8,514),K(n,"class","s-YGXJmi8diuJx"),v(n,tt,20,4,422),K(t,"class","login"),v(t,tt,19,0,398)},l:function(f){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(f,u){P(f,t,u),b(t,n),b(n,o),b(n,r),b(n,l),c||(s=st(x.call(null,o)),c=!0)},p:S,i:S,o:S,d:function(f){f&&E(t),c=!1,s()}};return y("SvelteRegisterBlock",{block:a,id:pt.name,type:"component",source:"",ctx:e}),a}function be(e,t,n){let{$$slots:o={},$$scope:r}=t;Z("ForgottenPassword",o,[]);let{remultKitData:l}=t;e.$$.on_mount.push(function(){l===void 0&&!("remultKitData"in t||e.$$.bound[e.$$.props.remultKitData])&&console.warn("<ForgottenPassword> was created without expected prop 'remultKitData'")});const c=["remultKitData"];return Object.keys(t).forEach(s=>{!~c.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<ForgottenPassword> was created with unknown prop '${s}'`)}),e.$$set=s=>{"remultKitData"in s&&n(0,l=s.remultKitData)},e.$capture_state=()=>({autofocus:x,remultKitData:l}),e.$inject_state=s=>{"remultKitData"in s&&n(0,l=s.remultKitData)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{e.$$.dirty&1&&(l||n(0,l={props:{paths:{base:"/kit/auth",login:"/login",forgottenPassword:"/forgotten-password"}}}))},[l]}class Ut extends Q{constructor(t){super(t),V(this,t,be,pt,ot,{remultKitData:0}),y("SvelteRegisterComponent",{component:this,tagName:"ForgottenPassword",options:t,id:pt.name})}get remultKitData(){throw new Error("<ForgottenPassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set remultKitData(t){throw new Error("<ForgottenPassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const D="src/lib/modules/auth/components/Login.svelte";function gt(e){let t,n,o,r,l,c,s,a,i,f,u,m,g,_,w,p;const d={c:function(){t=k("form"),n=k("p"),o=O(e[1]),r=O(e[2]),l=j(),c=k("label"),s=O(`Username
        `),a=k("input"),i=j(),f=k("label"),u=O(`Password
        `),m=k("input"),g=j(),_=k("button"),_.textContent="Login",v(n,D,43,4,774),K(a,"type","text"),v(a,D,46,8,841),v(c,D,44,4,808),K(m,"type","password"),v(m,D,50,8,952),v(f,D,48,4,919),v(_,D,52,4,1017),K(t,"class","s-W59Gs1JvsTvT"),v(t,D,42,0,729)},m:function(B,C){P(B,t,C),b(t,n),b(n,o),b(n,r),b(t,l),b(t,c),b(c,s),b(c,a),I(a,e[0]),b(t,i),b(t,f),b(f,u),b(f,m),I(m,e[4]),b(t,g),b(t,_),w||(p=[X(a,"input",e[8]),st(x.call(null,a)),X(m,"input",e[9]),X(t,"submit",Jt(e[6]),!1,!0,!1,!1)],w=!0)},p:function(B,C){C&2&&et(o,B[1]),C&4&&et(r,B[2]),C&1&&a.value!==B[0]&&I(a,B[0]),C&16&&m.value!==B[4]&&I(m,B[4])},d:function(B){B&&E(t),w=!1,nt(p)}};return y("SvelteRegisterBlock",{block:d,id:gt.name,type:"if",source:'(36:0) {#if view == \\"login\\"}',ctx:e}),d}function wt(e){let t,n,o,r,l,c,s,a,i,f,u,m;const g={c:function(){t=k("form"),n=k("p"),o=O(e[1]),r=O(e[2]),l=j(),c=k("label"),s=O(`PIN
        `),a=k("input"),i=j(),f=k("button"),f.textContent="Confirm",v(n,D,59,4,1124),K(a,"type","number"),K(a,"placeholder","556775"),v(a,D,62,8,1186),v(c,D,60,4,1158),v(f,D,64,4,1283),K(t,"class","s-W59Gs1JvsTvT"),v(t,D,58,0,1076)},m:function(w,p){P(w,t,p),b(t,n),b(n,o),b(n,r),b(t,l),b(t,c),b(c,s),b(c,a),I(a,e[5]),b(t,i),b(t,f),u||(m=[X(a,"input",e[10]),st(x.call(null,a)),X(t,"submit",Jt(handlePin),!1,!0,!1,!1)],u=!0)},p:function(w,p){p&2&&et(o,w[1]),p&4&&et(r,w[2]),p&32&&qt(a.value)!==w[5]&&I(a,w[5])},d:function(w){w&&E(t),u=!1,nt(m)}};return y("SvelteRegisterBlock",{block:g,id:wt.name,type:"if",source:'(52:0) {#if view == \\"pin\\"}',ctx:e}),g}function bt(e){let t,n,o=e[3]=="login"&&gt(e),r=e[3]=="pin"&&wt(e);const l={c:function(){o&&o.c(),t=j(),r&&r.c(),n=It()},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){o&&o.m(s,a),P(s,t,a),r&&r.m(s,a),P(s,n,a)},p:function(s,[a]){s[3]=="login"?o?o.p(s,a):(o=gt(s),o.c(),o.m(t.parentNode,t)):o&&(o.d(1),o=null),s[3]=="pin"?r?r.p(s,a):(r=wt(s),r.c(),r.m(n.parentNode,n)):r&&(r.d(1),r=null)},i:S,o:S,d:function(s){s&&(E(t),E(n)),o&&o.d(s),r&&r.d(s)}};return y("SvelteRegisterBlock",{block:l,id:bt.name,type:"component",source:"",ctx:e}),l}function _e(e,t,n){let{$$slots:o={},$$scope:r}=t;Z("Login",o,[]);let{remultKitData:l}=t,{view:c="login"}=t,{indentifier:s=""}=t,{msgError:a=""}=t,{msgSuccess:i=""}=t,f,u;async function m(){n(1,a=""),n(2,i="");try{await AuthController.signInPassword(s,f),await invalidateAll()}catch(d){isError(d)&&n(1,a=d.message??"")}}e.$$.on_mount.push(function(){l===void 0&&!("remultKitData"in t||e.$$.bound[e.$$.props.remultKitData])&&console.warn("<Login> was created without expected prop 'remultKitData'")});const g=["remultKitData","view","indentifier","msgError","msgSuccess"];Object.keys(t).forEach(d=>{!~g.indexOf(d)&&d.slice(0,2)!=="$$"&&d!=="slot"&&console.warn(`<Login> was created with unknown prop '${d}'`)});function _(){s=this.value,n(0,s)}function w(){f=this.value,n(4,f)}function p(){u=qt(this.value),n(5,u)}return e.$$set=d=>{"remultKitData"in d&&n(7,l=d.remultKitData),"view"in d&&n(3,c=d.view),"indentifier"in d&&n(0,s=d.indentifier),"msgError"in d&&n(1,a=d.msgError),"msgSuccess"in d&&n(2,i=d.msgSuccess)},e.$capture_state=()=>({autofocus:x,remultKitData:l,view:c,indentifier:s,msgError:a,msgSuccess:i,password:f,pincode:u,signIn:m}),e.$inject_state=d=>{"remultKitData"in d&&n(7,l=d.remultKitData),"view"in d&&n(3,c=d.view),"indentifier"in d&&n(0,s=d.indentifier),"msgError"in d&&n(1,a=d.msgError),"msgSuccess"in d&&n(2,i=d.msgSuccess),"password"in d&&n(4,f=d.password),"pincode"in d&&n(5,u=d.pincode)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{e.$$.dirty&128&&(l||n(7,l={props:{paths:{base:"/kit/auth",login:"/login",forgottenPassword:"/forgotten-password"}}}))},[s,a,i,c,f,u,m,l,_,w,p]}class zt extends Q{constructor(t){super(t),V(this,t,_e,bt,ot,{remultKitData:7,view:3,indentifier:0,msgError:1,msgSuccess:2}),y("SvelteRegisterComponent",{component:this,tagName:"Login",options:t,id:bt.name})}get remultKitData(){throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set remultKitData(t){throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get view(){throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set view(t){throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get indentifier(){throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set indentifier(t){throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get msgError(){throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set msgError(t){throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get msgSuccess(){throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set msgSuccess(t){throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const T="src/lib/modules/auth/Page.svelte";function Yt(e){let t;const n={c:function(){t=O("Forgot your password?")},m:function(r,l){P(r,t,l)},d:function(r){r&&E(t)}};return y("SvelteRegisterBlock",{block:n,id:Yt.name,type:"slot",source:"(19:10) <Link href={forgottenPasswordPath}>",ctx:e}),n}function Qt(e){let t,n,o,r,l;t=new zt({props:{remultKitData:e[0]},$$inline:!0}),r=new Pt({props:{href:e[2],$$slots:{default:[Yt]},$$scope:{ctx:e}},$$inline:!0});const c={c:function(){A(t.$$.fragment),n=j(),o=k("div"),A(r.$$.fragment),K(o,"class","form-footer s-NO-a_LAEXXH5"),v(o,T,19,8,549)},m:function(a,i){F(t,a,i),P(a,n,i),P(a,o,i),F(r,o,null),l=!0},p:function(a,i){const f={};i&1&&(f.remultKitData=a[0]),t.$set(f);const u={};i&4&&(u.href=a[2]),i&8&&(u.$$scope={dirty:i,ctx:a}),r.$set(u)},i:function(a){l||(L(t.$$.fragment,a),L(r.$$.fragment,a),l=!0)},o:function(a){R(t.$$.fragment,a),R(r.$$.fragment,a),l=!1},d:function(a){a&&(E(n),E(o)),N(t,a),N(r)}};return y("SvelteRegisterBlock",{block:c,id:Qt.name,type:"slot",source:"(15:6) <Route path={loginPath}>",ctx:e}),c}function Vt(e){let t;const n={c:function(){t=O("Back to login")},m:function(r,l){P(r,t,l)},d:function(r){r&&E(t)}};return y("SvelteRegisterBlock",{block:n,id:Vt.name,type:"slot",source:"(29:10) <Link href={loginPath}>",ctx:e}),n}function Zt(e){let t,n,o,r,l;t=new Ut({props:{remultKitData:e[0]},$$inline:!0}),r=new Pt({props:{href:e[1],$$slots:{default:[Vt]},$$scope:{ctx:e}},$$inline:!0});const c={c:function(){A(t.$$.fragment),n=j(),o=k("div"),A(r.$$.fragment),K(o,"class","form-footer s-NO-a_LAEXXH5"),v(o,T,29,8,802)},m:function(a,i){F(t,a,i),P(a,n,i),P(a,o,i),F(r,o,null),l=!0},p:function(a,i){const f={};i&1&&(f.remultKitData=a[0]),t.$set(f);const u={};i&2&&(u.href=a[1]),i&8&&(u.$$scope={dirty:i,ctx:a}),r.$set(u)},i:function(a){l||(L(t.$$.fragment,a),L(r.$$.fragment,a),l=!0)},o:function(a){R(t.$$.fragment,a),R(r.$$.fragment,a),l=!1},d:function(a){a&&(E(n),E(o)),N(t,a),N(r)}};return y("SvelteRegisterBlock",{block:c,id:Zt.name,type:"slot",source:"(25:6) <Route path={forgottenPasswordPath}>",ctx:e}),c}function Mt(e){let t,n;const o={c:function(){t=k("div"),n=k("small"),n.textContent="Nothing to see here",v(n,T,38,10,1001),K(t,"class","fallback s-NO-a_LAEXXH5"),v(t,T,37,8,968)},m:function(l,c){P(l,t,c),b(t,n)},p:S,d:function(l){l&&E(t)}};return y("SvelteRegisterBlock",{block:o,id:Mt.name,type:"slot",source:"(35:6) <Route fallback>",ctx:e}),o}function xt(e){let t,n,o,r,l,c;t=new z({props:{path:e[1],$$slots:{default:[Qt]},$$scope:{ctx:e}},$$inline:!0}),o=new z({props:{path:e[2],$$slots:{default:[Zt]},$$scope:{ctx:e}},$$inline:!0}),l=new z({props:{fallback:!0,$$slots:{default:[Mt]},$$scope:{ctx:e}},$$inline:!0});const s={c:function(){A(t.$$.fragment),n=j(),A(o.$$.fragment),r=j(),A(l.$$.fragment)},m:function(i,f){F(t,i,f),P(i,n,f),F(o,i,f),P(i,r,f),F(l,i,f),c=!0},p:function(i,f){const u={};f&2&&(u.path=i[1]),f&13&&(u.$$scope={dirty:f,ctx:i}),t.$set(u);const m={};f&4&&(m.path=i[2]),f&11&&(m.$$scope={dirty:f,ctx:i}),o.$set(m);const g={};f&8&&(g.$$scope={dirty:f,ctx:i}),l.$set(g)},i:function(i){c||(L(t.$$.fragment,i),L(o.$$.fragment,i),L(l.$$.fragment,i),c=!0)},o:function(i){R(t.$$.fragment,i),R(o.$$.fragment,i),R(l.$$.fragment,i),c=!1},d:function(i){i&&(E(n),E(r)),N(t,i),N(o,i),N(l,i)}};return y("SvelteRegisterBlock",{block:s,id:xt.name,type:"slot",source:"(14:4) <Route>",ctx:e}),s}function _t(e){let t,n,o,r;o=new z({props:{$$slots:{default:[xt]},$$scope:{ctx:e}},$$inline:!0});const l={c:function(){t=k("div"),n=k("div"),A(o.$$.fragment),K(n,"class","form s-NO-a_LAEXXH5"),v(n,T,14,2,444),K(t,"class","wrapper s-NO-a_LAEXXH5"),v(t,T,13,0,420)},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){P(s,t,a),b(t,n),F(o,n,null),r=!0},p:function(s,[a]){const i={};a&15&&(i.$$scope={dirty:a,ctx:s}),o.$set(i)},i:function(s){r||(L(o.$$.fragment,s),r=!0)},o:function(s){R(o.$$.fragment,s),r=!1},d:function(s){s&&E(t),N(o)}};return y("SvelteRegisterBlock",{block:l,id:_t.name,type:"component",source:"",ctx:e}),l}function ke(e,t,n){let o,r,{$$slots:l={},$$scope:c}=t;Z("Page",l,[]);let{remultKitData:s}=t;e.$$.on_mount.push(function(){s===void 0&&!("remultKitData"in t||e.$$.bound[e.$$.props.remultKitData])&&console.warn("<Page> was created without expected prop 'remultKitData'")});const a=["remultKitData"];return Object.keys(t).forEach(i=>{!~a.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<Page> was created with unknown prop '${i}'`)}),e.$$set=i=>{"remultKitData"in i&&n(0,s=i.remultKitData)},e.$capture_state=()=>({Route:z,Link:Pt,linkHandle:yt,ForgottenPassword:Ut,Login:zt,remultKitData:s,loginPath:r,forgottenPasswordPath:o}),e.$inject_state=i=>{"remultKitData"in i&&n(0,s=i.remultKitData),"loginPath"in i&&n(1,r=i.loginPath),"forgottenPasswordPath"in i&&n(2,o=i.forgottenPasswordPath)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),e.$$.update=()=>{e.$$.dirty&1&&n(2,o=s.props.paths.base+s.props.paths.forgottenPassword),e.$$.dirty&1&&n(1,r=s.props.paths.base+s.props.paths.login)},[s,r,o]}class ye extends Q{constructor(t){super(t),V(this,t,ke,_t,ot,{remultKitData:0}),y("SvelteRegisterComponent",{component:this,tagName:"Page",options:t,id:_t.name})}get remultKitData(){throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set remultKitData(t){throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}export{ye as default};
